import bpy

## IMAGE OPTIONS
# set the dimensions of any new images made, in pixels.
# [width, height].
tex_size = [512,512]

# set distance for the cage to extrude
bake_extrusion = .01

# texture margin for the baked material
bake_margin = 2

# choose if you want to bake the diffuse layer
bake_diffuse = True

# choose if you want to bake the roughness layer
bake_roughness = False

# choose if you want to bake the normal layer
bake_normal = False

# set the following variables to change the interpolation.
# of the nodes generated by this script.
# options are : 'Linear', 'Closest', 'Cubic', or 'Smart'.
diffuse_interpolation = 'Linear'
roughness_interpolation = 'Linear'
normal_interpolation = 'Linear'

## EXPORT OPTIONS
# choose if selcted objects should be exported.
# exported objects are saved as glbf files.
export = False

## SAVING OPTIONS
# set if the generated textures are saved or not.
# True or False.
save = False

# choose the path to save files too.
# dont forget to escape each slash with a \, otherwise blender may not find the path
path = ""

## ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- -----

# check that at least one bake option is true
# no_bakes is not defined so it will just throw an error and stop the script
if sum([bake_diffuse,bake_roughness,bake_normal]) == 0 : no_bakes()

# easy references to common objects used by blender.
C = bpy.context
D = bpy.data
O = C.view_layer.objects
I = bpy.data.images

active = C.active_object
selected = C.selected_objects ; selected.remove(active)
for object in selected : object.select_set(False)
material = D.materials[active.name]
nodes = material.node_tree.nodes
tree = material.node_tree

# make sure the path ends in a trailing \
if save and path[-1] != '\\' : path += '\\'

# find the bsdf shader
if 'Principled BSDF' in nodes : bsdf = nodes['Principled BSDF']
else:
    bsdf = nodes.new('ShaderNodeBsdfPrincipled')
    bsdf.name = 'Principled BSDF'
    bsdf.label = 'Principled BSDF'

# link the bsdf to the materal output
tree.links.new( bsdf.outputs['BSDF'], nodes['Material Output'].inputs['Surface'])

# define the function to perform a loop bake
def loop_bake(_type,_interpolation):
    # create or find the target texture
    if active.name + "_" + _type in I : _texture = I[active.name + "_" + _type]
    else : _texture = bpy.data.images.new(active.name + "_" + _type, tex_size[0], tex_size[1])
    
    # create or find the target node
    if _type in nodes : _node = nodes[_type]
    else : _node = nodes.new('ShaderNodeTexImage')
    
    # set node properties
    _node.name = _type
    _node.label = _type
    _node.interpolation = _interpolation
    _node.image = _texture
    _node.select = True
    nodes.active = _node
    
    # bake to the target node
    for object in selected:
        O.active = object
        active.select_set(True)
        bpy.ops.object.bake(
            type = _type.upper(),
            use_selected_to_active = True, 
            target = 'IMAGE_TEXTURES',
            margin = bake_margin,
            cage_extrusion = bake_extrusion
            )
    
    # link nodes and textures and shader
    match _type :
        case 'diffuse' : tree.links.new(_node.outputs["Color"], bsdf.inputs['Base Color'])
        case 'roughness' : tree.links.new(_node.outputs["Color"], bsdf.inputs['Roughness'])
        case 'normal' : 
            if 'Bump' in nodes : bump = nodes['Bump']
            else: 
                bump = nodes.new('ShaderNodeBump')
                bump.name = 'Bump'
                bump.label = 'Bump'
            tree.links.new(_node.outputs["Color"], bump.inputs['Height'])
            tree.links.new(bump.outputs["Normal"], bsdf.inputs['Normal'])
    
    # check if we should save the baked texture or not
    if save : _texture.save_render(filepath = path + active.name + '_' + _type + '.png')
    
    # finshed baking that part and print to console
    print('finished bake of : ',_type)       

# do the actual baking
if bake_diffuse : loop_bake('diffuse',diffuse_interpolation)
if bake_roughness : loop_bake('roughness',roughness_interpolation)
if bake_normal : loop_bake('normal',normal_interpolation)

# if export, export
if export:
    for object in selected :
        O.active = object
        bpy.ops.export_scene.gltf(
            use_active_scene = True,
            filepath = path + object.name,
            export_animations = False
            )

# reset the selcted and active objects to avoid confusion
O.active = active
for object in selected : object.select_set(True)

print('\n \nJOBS DONE\n')
